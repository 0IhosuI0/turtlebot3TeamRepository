#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ë°•ë¬¼ê´€ ê°€ì´ë“œ ë¡œë´‡ - í„°í‹€ë´‡ ì œì–´ ëª¨ë“ˆ
Gazebo ì‹œë®¬ë ˆì´ì…˜ ë° ì‹¤ì œ í„°í‹€ë´‡ ì—°ë™ (ìˆ˜ì •ëœ ë²„ì „)
"""

import time
import random
import json
import math
from datetime import datetime

# ROS2 ë° Gazebo ì—°ë™ì„ ìœ„í•œ import (ìˆì„ ê²½ìš°ì—ë§Œ)
try:
    import rclpy
    from rclpy.node import Node
    from geometry_msgs.msg import Twist, PoseStamped
    from nav_msgs.msg import OccupancyGrid
    from sensor_msgs.msg import LaserScan, Image
    from std_msgs.msg import String
    ROS_AVAILABLE = True
    print("âœ… ROS2 í™˜ê²½ ê°ì§€ë¨ - Gazebo ì—°ë™ ëª¨ë“œ")
except ImportError:
    ROS_AVAILABLE = False
    print("âš ï¸ ROS2 ë¯¸ì„¤ì¹˜ - ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ ë™ì‘")

class TurtlebotController:
    def __init__(self):
        """í„°í‹€ë´‡ ì»¨íŠ¸ë¡¤ëŸ¬ ì´ˆê¸°í™”"""
        self.connected = False
        self.ros_node = None
        self.current_position = {"x": 0, "y": 0, "theta": 0}
        self.battery_level = 100
        self.moving = False
        self.current_location = "ì…êµ¬"
       
        # Gazebo ë§µì—ì„œì˜ 7ê°œ ì „ì‹œí’ˆ ìœ„ì¹˜ (ë°•ë¬¼ê´€ ë§µì— ë§ê²Œ ì¡°ì •)
        self.exhibition_positions = {
            1: {"x": 2.0, "y": 6.0, "theta": 0.0, "name": "ê³ êµ¬ë ¤ ë²½í™”", "location": "Aë™ 1ì¸µ"},
            2: {"x": 6.0, "y": 6.0, "theta": 0.0, "name": "ì¡°ì„  ë°±ì", "location": "Aë™ 2ì¸µ"},
            3: {"x": 2.0, "y": 3.0, "theta": 0.0, "name": "ë¶ˆêµ ì¡°ê°", "location": "Bë™ 1ì¸µ"},
            4: {"x": 6.0, "y": 3.0, "theta": 0.0, "name": "ë¯¼ì† ìƒí™œìš©í’ˆ", "location": "Bë™ 2ì¸µ"},
            5: {"x": 2.0, "y": 0.0, "theta": 0.0, "name": "ê·¼í˜„ëŒ€ íšŒí™”", "location": "Cë™ 1ì¸µ"},
            6: {"x": 6.0, "y": 0.0, "theta": 0.0, "name": "ê¸ˆì† ê³µì˜ˆí’ˆ", "location": "Cë™ 2ì¸µ"},
            7: {"x": 4.0, "y": -3.0, "theta": 0.0, "name": "ì „í†µ ì˜ë³µ", "location": "Dë™ 1ì¸µ"}
        }
       
        # ë¡œë´‡ ìƒíƒœ
        self.status = {
            "mode": "idle",  # idle, moving, guiding, tracking
            "speed": "normal",  # slow, normal, fast
            "voice_enabled": True,
            "led_status": "green",
            "gazebo_connected": False,
            "navigation_active": False
        }
       
        # ROS2 ì´ˆê¸°í™” (ê°€ëŠ¥í•œ ê²½ìš°)
        if ROS_AVAILABLE:
            self.init_ros_node()

    def init_ros_node(self):
        """ROS2 ë…¸ë“œ ì´ˆê¸°í™”"""
        try:
            if not rclpy.ok():
                rclpy.init()
            self.ros_node = rclpy.create_node('museum_guide_controller')
           
            # Publishers
            self.cmd_vel_pub = self.ros_node.create_publisher(Twist, '/cmd_vel', 10)
            self.goal_pub = self.ros_node.create_publisher(PoseStamped, '/goal_pose', 10)
           
            # Subscribers  
            self.laser_sub = self.ros_node.create_subscription(
                LaserScan, '/scan', self.laser_callback, 10)
           
            print("ğŸ¤– ROS2 ë…¸ë“œ ì´ˆê¸°í™” ì™„ë£Œ")
            self.status["gazebo_connected"] = True
        except Exception as e:
            print(f"âŒ ROS2 ë…¸ë“œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            self.status["gazebo_connected"] = False

    def laser_callback(self, msg):
        """ë¼ì´ë‹¤ ì„¼ì„œ ì½œë°±"""
        # ì¥ì• ë¬¼ ê°ì§€ ë¡œì§
        try:
            min_distance = min([r for r in msg.ranges if not math.isinf(r) and not math.isnan(r)])
            if min_distance < 0.5:  # 50cm ì´ë‚´ ì¥ì• ë¬¼
                print("âš ï¸ ì¥ì• ë¬¼ ê°ì§€!")
        except:
            pass

    def connect(self):
        """í„°í‹€ë´‡ ì—°ê²° (Gazebo ë˜ëŠ” ì‹¤ì œ ë¡œë´‡)"""
        print("ğŸ¤– í„°í‹€ë´‡ ì—°ê²° ì‹œë„ ì¤‘...")
       
        if ROS_AVAILABLE and self.status["gazebo_connected"]:
            print("ğŸ® Gazebo ì‹œë®¬ë ˆì´ì…˜ í™˜ê²½ ì—°ê²° ì¤‘...")
            time.sleep(2)
            self.connected = True
            self.current_location = "ì‹œë®¬ë ˆì´ì…˜ ì…êµ¬"
            self.battery_level = 100
            print("âœ… Gazebo í„°í‹€ë´‡ ì—°ê²° ì„±ê³µ!")
           
        else:
            print("ğŸ“¡ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ ì—°ê²° ì¤‘...")
            time.sleep(2)
            # ì‹œë®¬ë ˆì´ì…˜: 90% í™•ë¥ ë¡œ ì—°ê²° ì„±ê³µ
            if random.random() > 0.1:
                self.connected = True
                self.current_location = "ì…êµ¬"
                self.battery_level = random.randint(80, 100)
                print("âœ… ì‹œë®¬ë ˆì´ì…˜ í„°í‹€ë´‡ ì—°ê²° ì„±ê³µ!")
            else:
                print("âŒ í„°í‹€ë´‡ ì—°ê²° ì‹¤íŒ¨!")
                return False
       
        self._initialize_robot()
        return True

    def _initialize_robot(self):
        """ë¡œë´‡ ì´ˆê¸°í™”"""
        print("ğŸ”§ í„°í‹€ë´‡ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...")
        time.sleep(1)
       
        # ì„¼ì„œ ì²´í¬
        if ROS_AVAILABLE:
            print("ğŸ“¡ ë¼ì´ë‹¤ ì„¼ì„œ í™•ì¸...")
            print("ğŸ“· ì¹´ë©”ë¼ ì„¼ì„œ í™•ì¸...")
            print("ğŸ—ºï¸ ë„¤ë¹„ê²Œì´ì…˜ ìŠ¤íƒ í™•ì¸...")
        else:
            print("ğŸ“¡ ì„¼ì„œ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ...")
        time.sleep(0.5)
       
        # ëª¨í„° ì²´í¬
        print("âš™ï¸ ëª¨í„° ìƒíƒœ í™•ì¸...")
        time.sleep(0.5)
       
        print("âœ… í„°í‹€ë´‡ ì´ˆê¸°í™” ì™„ë£Œ!")

    def move_to_exhibition(self, exhibit_id):
        """ì§€ì •ëœ ì „ì‹œí’ˆìœ¼ë¡œ ì´ë™ (ìˆ˜ì •ëœ ë²„ì „)"""
        if not self.connected:
            print("âŒ í„°í‹€ë´‡ì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
            return False
       
        if exhibit_id not in self.exhibition_positions:
            print(f"âŒ ì „ì‹œí’ˆ {exhibit_id}ì˜ ìœ„ì¹˜ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return False
       
        target = self.exhibition_positions[exhibit_id]
       
        print(f"ğŸš¶ â™‚ï¸ {target['name']}ë¡œ ì´ë™ ì‹œì‘...")
        print(f"ğŸ“ ëª©ì ì§€: {target['location']} ({target['x']:.1f}, {target['y']:.1f})")
       
        self.status["mode"] = "moving"
        self.moving = True
       
        if ROS_AVAILABLE and self.status["gazebo_connected"]:
            # Gazebo Navigation ì‚¬ìš©
            self._navigate_to_position(target)
        else:
            # ì‹œë®¬ë ˆì´ì…˜ ì´ë™
            self._simulate_movement(target)
       
        self.current_position = {"x": target["x"], "y": target["y"], "theta": target["theta"]}
        self.current_location = target["location"]
        self.status["mode"] = "guiding"
        self.moving = False
       
        print(f"âœ… {target['name']} ë„ì°© ì™„ë£Œ!")
        return True

    def _navigate_to_position(self, target):
        """Gazebo Navigationìœ¼ë¡œ ìœ„ì¹˜ ì´ë™ (ì‹¤ì œ ì›€ì§ì„ í¬í•¨)"""
        try:
            print("ğŸ—ºï¸ Gazeboì—ì„œ í„°í‹€ë´‡ ì´ë™ ì‹œì‘...")
           
            # ì‹¤ì œ í„°í‹€ë´‡ ì›€ì§ì„ ëª…ë ¹ ì „ì†¡
            self._send_movement_commands(target)
           
            # Navigation2 ëª©í‘œ ì„¤ì • (ì„ íƒì‚¬í•­)
            if hasattr(self, 'goal_pub'):
                goal_msg = PoseStamped()
                goal_msg.header.frame_id = 'map'
                goal_msg.header.stamp = self.ros_node.get_clock().now().to_msg()
               
                goal_msg.pose.position.x = target['x']
                goal_msg.pose.position.y = target['y']
                goal_msg.pose.position.z = 0.0
               
                # thetaë¥¼ quaternionìœ¼ë¡œ ë³€í™˜ (ê°„ë‹¨í™”)
                goal_msg.pose.orientation.z = math.sin(target['theta'] / 2)
                goal_msg.pose.orientation.w = math.cos(target['theta'] / 2)
               
                self.goal_pub.publish(goal_msg)
                print("ğŸ¯ Navigation2 ëª©í‘œ ì„¤ì • ì™„ë£Œ")
               
        except Exception as e:
            print(f"âŒ Navigation ì˜¤ë¥˜: {e}")
            self._simulate_movement(target)

    def _send_movement_commands(self, target):
        """ì‹¤ì œ ROS2 ëª…ë ¹ìœ¼ë¡œ í„°í‹€ë´‡ ì›€ì§ì´ê¸°"""
        try:
            if not self.ros_node or not hasattr(self, 'cmd_vel_pub'):
                print("âŒ ROS2 í¼ë¸”ë¦¬ì…”ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
                return
           
            # ëª©í‘œ ë°©í–¥ ê³„ì‚°
            current_x, current_y = self.current_position["x"], self.current_position["y"]
            target_x, target_y = target["x"], target["y"]
           
            dx = target_x - current_x
            dy = target_y - current_y
            distance = math.sqrt(dx**2 + dy**2)
           
            print(f"ğŸ“ ê³„ì‚°ëœ ê±°ë¦¬: {distance:.2f}m")
           
            if distance > 0.1:  # 10cm ì´ìƒë§Œ ì›€ì§ì„
                # íšŒì „ ë¨¼ì € (ëª©í‘œ ë°©í–¥ìœ¼ë¡œ)
                target_angle = math.atan2(dy, dx)
                self._rotate_to_angle(target_angle)
               
                # ì§ì§„ ì´ë™
                move_duration = max(3, int(distance * 2))  # ê±°ë¦¬ì— ë¹„ë¡€í•œ ì‹œê°„
                linear_speed = min(0.3, distance / move_duration)  # ì ì ˆí•œ ì†ë„ ê³„ì‚°
               
                print(f"ğŸ¤– ROS2 ì´ë™ ëª…ë ¹: ì†ë„={linear_speed:.2f}m/s, ì‹œê°„={move_duration}ì´ˆ")
               
                # Twist ë©”ì‹œì§€ë¡œ ì›€ì§ì„ ëª…ë ¹ ì „ì†¡
                twist = Twist()
                twist.linear.x = linear_speed
               
                # ì¼ì • ì‹œê°„ ë™ì•ˆ ì›€ì§ì„
                for i in range(move_duration):
                    if not self.moving:
                        break
                   
                    self.cmd_vel_pub.publish(twist)
                    print(f"ğŸš¶ â™‚ï¸ ì´ë™ ì¤‘... {((i+1)/move_duration*100):.0f}%")
                   
                    # ROS2 ìŠ¤í•€ (ì½œë°± ì²˜ë¦¬)
                    if self.ros_node:
                        rclpy.spin_once(self.ros_node, timeout_sec=0.1)
                   
                    time.sleep(1)
                    self.battery_level -= 0.2
               
                # ì •ì§€ ëª…ë ¹
                stop_twist = Twist()
                self.cmd_vel_pub.publish(stop_twist)
                print("ğŸ›‘ í„°í‹€ë´‡ ì •ì§€")
               
        except Exception as e:
            print(f"âŒ ROS2 ì›€ì§ì„ ëª…ë ¹ ì‹¤íŒ¨: {e}")
            print("ğŸ”„ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ ì „í™˜...")
            self._simulate_movement(target)

    def _rotate_to_angle(self, target_angle):
        """ì§€ì •ëœ ê°ë„ë¡œ íšŒì „"""
        try:
            current_angle = self.current_position.get("theta", 0)
            angle_diff = target_angle - current_angle
           
            # ê°ë„ ì •ê·œí™” (-Ï€ ~ Ï€)
            while angle_diff > math.pi:
                angle_diff -= 2 * math.pi
            while angle_diff < -math.pi:
                angle_diff += 2 * math.pi
           
            if abs(angle_diff) > 0.1:  # 0.1 ë¼ë””ì•ˆ ì´ìƒë§Œ íšŒì „
                angular_speed = 0.5 if angle_diff > 0 else -0.5
                rotation_time = int(abs(angle_diff) * 2)  # íšŒì „ ì‹œê°„ ê³„ì‚°
               
                print(f"ğŸ”„ íšŒì „ ì¤‘... {math.degrees(angle_diff):.1f}ë„")
               
                twist = Twist()
                twist.angular.z = angular_speed
               
                for i in range(rotation_time):
                    if not self.moving:
                        break
                    self.cmd_vel_pub.publish(twist)
                    time.sleep(0.5)
               
                # íšŒì „ ì •ì§€
                stop_twist = Twist()
                self.cmd_vel_pub.publish(stop_twist)
                self.current_position["theta"] = target_angle
               
        except Exception as e:
            print(f"âŒ íšŒì „ ëª…ë ¹ ì‹¤íŒ¨: {e}")

    def _simulate_movement(self, target):
        """ì´ë™ ì‹œë®¬ë ˆì´ì…˜ (ìˆ˜ì •ëœ ë²„ì „)"""
        current_x, current_y = self.current_position["x"], self.current_position["y"]
        target_x, target_y = target["x"], target["y"]
       
        # ê±°ë¦¬ ê³„ì‚°
        distance = math.sqrt((target_x - current_x) ** 2 + (target_y - current_y) ** 2)
       
        # ì´ë™ ì‹œê°„ ê³„ì‚° ìˆ˜ì • (ìµœì†Œ 5ì´ˆ, ê±°ë¦¬ì— ë¹„ë¡€)
        move_time = max(5, int(distance * 2))  # ê±°ë¦¬ 1më‹¹ 2ì´ˆ
       
        print(f"ğŸ“ ì´ë™ ê±°ë¦¬: {distance:.2f}m")
        print(f"â±ï¸ ì˜ˆìƒ ì‹œê°„: {move_time}ì´ˆ")
       
        # ë‹¨ê³„ë³„ ì´ë™ í‘œì‹œ
        for i in range(move_time):
            if not self.moving:
                break
            progress = (i + 1) / move_time * 100
            print(f"ğŸš¶ â™‚ï¸ ì‹œë®¬ë ˆì´ì…˜ ì´ë™ ì¤‘... {progress:.0f}%")
            time.sleep(1)
           
            # ë°°í„°ë¦¬ ì†Œëª¨
            self.battery_level -= 0.1
           
            # ì¥ì• ë¬¼ íšŒí”¼ ì‹œë®¬ë ˆì´ì…˜ (ê°€ë”)
            if random.random() < 0.1:
                print("âš ï¸ ì¥ì• ë¬¼ ê°ì§€, ê²½ë¡œ ì¬ê³„íš ì¤‘...")
                time.sleep(0.5)

    def follow_user_to_exhibition(self, exhibit_id):
        """ì‚¬ìš©ìë¥¼ ë”°ë¼ ì „ì‹œí’ˆìœ¼ë¡œ ì´ë™ (íŠ¸ë˜í‚¹ ëª¨ë“œ)"""
        if not self.connected:
            print("âŒ í„°í‹€ë´‡ì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
            return False
       
        target = self.exhibition_positions.get(exhibit_id)
        if not target:
            print(f"âŒ ì „ì‹œí’ˆ {exhibit_id}ì˜ ìœ„ì¹˜ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return False
       
        print(f"ğŸ‘¥ ì‚¬ìš©ìë¥¼ ë”°ë¼ {target['name']}ë¡œ ì´ë™ ì¤‘...")
        print("ğŸ¤– ì•ˆì „ê±°ë¦¬ 1.5më¥¼ ìœ ì§€í•˜ë©° ì¶”ì¢…í•©ë‹ˆë‹¤.")
       
        self.status["mode"] = "tracking"
        self.moving = True
       
        # ì‚¬ìš©ì ì¶”ì¢… ì‹œë®¬ë ˆì´ì…˜
        self._simulate_user_following(target)
       
        self.current_position = {"x": target["x"], "y": target["y"], "theta": target["theta"]}
        self.current_location = target["location"]
        self.status["mode"] = "guiding"
        self.moving = False
       
        print(f"âœ… {target['name']} ìœ„ì¹˜ì—ì„œ ê°€ì´ë“œ ëŒ€ê¸° ì¤‘")
        return True

    def _simulate_user_following(self, target):
        """ì‚¬ìš©ì ë”°ë¼ê°€ê¸° ì‹œë®¬ë ˆì´ì…˜"""
        print("ğŸ‘€ ì‚¬ìš©ì ìœ„ì¹˜ ì¶”ì  í™œì„±í™”...")
        time.sleep(1)
       
        if ROS_AVAILABLE:
            print("ğŸ“¡ ë¼ì´ë‹¤ë¡œ ì‚¬ìš©ì ê°ì§€ ì¤‘...")
        else:
            print("ğŸ¤– ì‹œë®¬ë ˆì´ì…˜ ì‚¬ìš©ì ì¶”ì  ì¤‘...")
       
        # ë”°ë¼ê°€ê¸° ë™ì‘ ì‹œë®¬ë ˆì´ì…˜
        for i in range(4):
            print(f"ğŸ‘¥ ì‚¬ìš©ì ì¶”ì¢… ì¤‘... {i+1}/4")
            time.sleep(1.5)
            self.battery_level -= 0.2
           
            if random.random() < 0.2:
                print("âš ï¸ ì‚¬ìš©ìê°€ ë„ˆë¬´ ë¹ ë¦…ë‹ˆë‹¤. ì†ë„ ì¡°ì ˆ ì¤‘...")
                time.sleep(0.5)

    def detect_sticker(self):
        """QRì½”ë“œ/ìŠ¤í‹°ì»¤ ì¸ì‹ (ì¹´ë©”ë¼ ì‚¬ìš©)"""
        if not self.connected:
            return None
       
        if ROS_AVAILABLE:
            # ì‹¤ì œ ì¹´ë©”ë¼ ì´ë¯¸ì§€ ì²˜ë¦¬ (OpenCV)
            print("ğŸ“· ì¹´ë©”ë¼ë¡œ QRì½”ë“œ ìŠ¤ìº” ì¤‘...")
            # TODO: OpenCV QR ì½”ë“œ ì¸ì‹ êµ¬í˜„
       
        # ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ
        detection_chance = random.random()
       
        if detection_chance < 0.3:  # 30% í™•ë¥ ë¡œ ìŠ¤í‹°ì»¤ ê°ì§€
            detected_id = random.randint(1, 7)
            print(f"ğŸ” QRì½”ë“œ ì¸ì‹: ì „ì‹œí’ˆ {detected_id}ë²ˆ")
            return detected_id
       
        return None

    def play_sound(self, sound_type):
        """ì‚¬ìš´ë“œ ì¬ìƒ (TTS ë˜ëŠ” ì‚¬ì „ë…¹ìŒ)"""
        sounds = {
            "welcome": "í™˜ì˜í•©ë‹ˆë‹¤! ë°•ë¬¼ê´€ ê°€ì´ë“œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.",
            "arrived": "ëª©ì ì§€ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤.",
            "warning": "ì£¼ì˜í•˜ì„¸ìš”. ì¥ì• ë¬¼ì´ ìˆìŠµë‹ˆë‹¤.",
            "goodbye": "ê´€ëŒí•´ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤!",
            "following": "ì•ˆì „ê±°ë¦¬ë¥¼ ìœ ì§€í•˜ë©° ë”°ë¼ê°€ê² ìŠµë‹ˆë‹¤."
        }
       
        message = sounds.get(sound_type, "")
       
        if self.status["voice_enabled"] and message:
            print(f"ğŸ”Š ìŒì„±ì•ˆë‚´: {message}")
           
            # ì‹¤ì œ TTS ì‚¬ìš© (ì„ íƒì‚¬í•­)
            try:
                # ë¦¬ëˆ…ìŠ¤ espeak ì‚¬ìš© (ì„¤ì¹˜ í•„ìš”: sudo apt install espeak)
                import os
                os.system(f'espeak -v ko "{message}" 2>/dev/null')
            except:
                # TTS ì—†ìœ¼ë©´ í…ìŠ¤íŠ¸ë§Œ í‘œì‹œ
                print("ğŸ”‡ ìŒì„± ì¶œë ¥ ì¥ì¹˜ ì—†ìŒ - í…ìŠ¤íŠ¸ë¡œ í‘œì‹œ")
           
            time.sleep(1)

    def get_gazebo_status(self):
        """Gazebo ìƒíƒœ í™•ì¸"""
        if ROS_AVAILABLE and self.status["gazebo_connected"]:
            return {
                "simulation": "Gazebo í™œì„±",
                "map_loaded": True,
                "navigation": "Navigation2 í™œì„±",
                "sensors": "ë¼ì´ë‹¤+ì¹´ë©”ë¼ í™œì„±"
            }
        else:
            return {
                "simulation": "ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ",
                "map_loaded": False,
                "navigation": "ì‹œë®¬ë ˆì´ì…˜",
                "sensors": "ê°€ìƒ ì„¼ì„œ"
            }

    def get_status(self):
        """í„°í‹€ë´‡ ìƒíƒœ ì •ë³´ ë°˜í™˜"""
        gazebo_info = self.get_gazebo_status()
       
        return {
            "connected": self.connected,
            "battery": round(self.battery_level),
            "location": self.current_location,
            "position": self.current_position,
            "moving": self.moving,
            "mode": self.status["mode"],
            "speed": self.status["speed"],
            "voice_enabled": self.status["voice_enabled"],
            "led_status": self.status["led_status"],
            "gazebo_status": gazebo_info,
            "ros_available": ROS_AVAILABLE,
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

    def emergency_stop(self):
        """ê¸´ê¸‰ ì •ì§€"""
        print("ğŸ›‘ ê¸´ê¸‰ ì •ì§€!")
        self.moving = False
        self.status["mode"] = "idle"
       
        if ROS_AVAILABLE and self.ros_node and hasattr(self, 'cmd_vel_pub'):
            # ROSë¡œ ì •ì§€ ëª…ë ¹ ì „ì†¡
            stop_msg = Twist()
            self.cmd_vel_pub.publish(stop_msg)
       
        print("âœ… ì•ˆì „í•˜ê²Œ ì •ì§€í–ˆìŠµë‹ˆë‹¤.")

    def stop_and_disconnect(self):
        """ì •ì§€ ë° ì—°ê²° í•´ì œ"""
        print("ğŸ›‘ í„°í‹€ë´‡ì„ ì•ˆì „í•˜ê²Œ ì •ì§€ì‹œí‚µë‹ˆë‹¤...")
       
        if self.moving:
            self.emergency_stop()
       
        # ê¸°ì§€ë¡œ ë³µê·€
        if self.current_location != "ì…êµ¬":
            print("ğŸ  ê¸°ì§€ë¡œ ë³µê·€ ì¤‘...")
            # ë³µê·€ ë¡œì§
       
        # ROS ì¢…ë£Œ
        if ROS_AVAILABLE and self.ros_node:
            try:
                self.ros_node.destroy_node()
                rclpy.shutdown()
                print("ğŸ¤– ROS2 ë…¸ë“œ ì¢…ë£Œ")
            except:
                pass
       
        self.connected = False
        self.status["mode"] = "offline"
       
        print("âœ… í„°í‹€ë´‡ì´ ì•ˆì „í•˜ê²Œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")

    def set_speed(self, speed):
        """ì´ë™ ì†ë„ ì„¤ì •"""
        valid_speeds = ["slow", "normal", "fast"]
        if speed in valid_speeds:
            self.status["speed"] = speed
            print(f"ğŸƒ â™‚ï¸ ì´ë™ ì†ë„ë¥¼ '{speed}'ë¡œ ì„¤ì •í–ˆìŠµë‹ˆë‹¤.")
            return True
        else:
            print(f"âŒ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ì†ë„ ì„¤ì •: {speed}")
            return False

    def set_voice_guide(self, enabled):
        """ìŒì„± ì•ˆë‚´ ì„¤ì •"""
        self.status["voice_enabled"] = enabled
        status_text = "í™œì„±í™”" if enabled else "ë¹„í™œì„±í™”"
        print(f"ğŸ”Š ìŒì„± ì•ˆë‚´ë¥¼ {status_text}í–ˆìŠµë‹ˆë‹¤.")

    def return_to_base(self):
        """ê¸°ì§€ë¡œ ë³µê·€"""
        print("ğŸ  ê¸°ì§€ë¡œ ë³µê·€ ì¤‘...")
       
        self.status["mode"] = "moving"
        self.moving = True
       
        # ê¸°ì§€ ìœ„ì¹˜ (ì…êµ¬)
        base_position = {"x": 0, "y": 0, "theta": 0}
       
        # ë³µê·€ ì‹œë®¬ë ˆì´ì…˜
        distance = math.sqrt(self.current_position["x"] ** 2 + self.current_position["y"] ** 2)
        move_time = max(2, int(distance / 15))  # ë³µê·€ëŠ” ì¡°ê¸ˆ ë” ë¹ ë¥´ê²Œ
       
        for i in range(move_time):
            progress = (i + 1) / move_time * 100
            print(f"ğŸ  ê¸°ì§€ë¡œ ë³µê·€ ì¤‘... {progress:.0f}%")
            time.sleep(1)
            self.battery_level -= 0.1
       
        self.current_position = base_position
        self.current_location = "ì…êµ¬"
        self.status["mode"] = "idle"
        self.moving = False
       
        print("âœ… ê¸°ì§€ ë³µê·€ ì™„ë£Œ!")

    def charge_battery(self, duration=10):
        """ë°°í„°ë¦¬ ì¶©ì „ ì‹œë®¬ë ˆì´ì…˜"""
        print("ğŸ”Œ ë°°í„°ë¦¬ ì¶©ì „ ì¤‘...")
       
        for i in range(duration):
            if self.battery_level < 100:
                self.battery_level = min(100, self.battery_level + 2)
                print(f"ğŸ”‹ ì¶©ì „ ì¤‘... {self.battery_level}%")
            else:
                print("ğŸ”‹ ë°°í„°ë¦¬ ì¶©ì „ ì™„ë£Œ!")
                break
            time.sleep(0.5)

    def check_low_battery(self):
        """ë°°í„°ë¦¬ ë¶€ì¡± í™•ì¸"""
        return self.battery_level < 20

    def set_led_color(self, color):
        """LED ìƒ‰ìƒ ì„¤ì •"""
        valid_colors = ["red", "green", "blue", "yellow", "purple"]
        if color in valid_colors:
            self.status["led_status"] = color
            print(f"ğŸ’¡ LEDë¥¼ {color}ìƒ‰ìœ¼ë¡œ ì„¤ì •í–ˆìŠµë‹ˆë‹¤.")
        else:
            print(f"âŒ ì˜¬ë°”ë¥´ì§€ ì•Šì€ LED ìƒ‰ìƒ: {color}")

    def get_sensor_data(self):
        """ì„¼ì„œ ë°ì´í„° ì¡°íšŒ"""
        # ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” ë¼ì´ë‹¤, ì¹´ë©”ë¼, IMU ë“±ì˜ ë°ì´í„°
        return {
            "lidar": {
                "front_distance": random.uniform(0.5, 5.0),
                "obstacles_detected": random.choice([True, False])
            },
            "camera": {
                "sticker_detected": random.choice([True, False]),
                "people_detected": random.randint(0, 3)
            },
            "imu": {
                "orientation": random.uniform(0, 360),
                "stability": "stable"
            },
            "temperature": random.uniform(20, 25),
            "humidity": random.uniform(40, 60)
        }

    def diagnostic_check(self):
        """ì‹œìŠ¤í…œ ì§„ë‹¨"""
        print("ğŸ” í„°í‹€ë´‡ ì§„ë‹¨ ì‹¤í–‰ ì¤‘...")
       
        diagnostics = {
            "battery_health": "ì–‘í˜¸" if self.battery_level > 50 else "ì ê²€ í•„ìš”",
            "motor_status": "ì •ìƒ",
            "sensor_status": "ì •ìƒ",
            "network_status": "ì—°ê²°ë¨" if self.connected else "ì—°ê²° ì•ˆë¨",
            "memory_usage": f"{random.randint(30, 70)}%",
            "cpu_temperature": f"{random.randint(35, 55)}Â°C",
            "ros2_status": "í™œì„±" if ROS_AVAILABLE else "ë¹„í™œì„±"
        }
       
        print("ğŸ“‹ ì§„ë‹¨ ê²°ê³¼:")
        for item, status in diagnostics.items():
            print(f"   {item}: {status}")
       
        return diagnostics
